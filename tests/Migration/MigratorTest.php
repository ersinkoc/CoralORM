<?php

declare(strict_types=1);

namespace Tests\YourOrm\Migration;

use YourOrm\Connection;
use YourOrm\Migration\Migrator;
use YourOrm\Migration\SchemaBuilder;
use YourOrm\Migration\AbstractMigration;
use YourOrm\QueryBuilder; // Used by Migrator
use PHPUnit\Framework\TestCase;
use PHPUnit\Framework\MockObject\MockObject;
use PDOException; // For testing ensureMigrationsTableExists
use PDOStatement; // For mocking QueryBuilder results

// Dummy migration class for testing runUp/runDown
class CreateUsersTable_20230101000000 extends AbstractMigration
{
    public static bool $upCalled = false;
    public static bool $downCalled = false;

    public function up(SchemaBuilder $schema): void { self::$upCalled = true; }
    public function down(SchemaBuilder $schema): void { self::$downCalled = true; }
}
// Another dummy migration
class AddStatusToUsersTable_20230102000000 extends AbstractMigration
{
    public function up(SchemaBuilder $schema): void {}
    public function down(SchemaBuilder $schema): void {}
}


class MigratorTest extends TestCase
{
    private MockObject|Connection $connectionMock;
    private MockObject|QueryBuilder $qbMock; // Migrator uses QueryBuilder internally
    private string $migrationsPath;
    private Migrator $migrator;

    protected function setUp(): void
    {
        $this->connectionMock = $this->createMock(Connection::class);
        $this->qbMock = $this->createMock(QueryBuilder::class);

        // Migrator instantiates its own QueryBuilder. So, we can't directly inject qbMock.
        // Instead, we mock Connection::execute() which QueryBuilder will eventually call.
        // This makes testing Migrator's DB interaction a bit indirect.
        // For methods directly using QueryBuilder for SELECT (getExecutedMigrations, getNextBatchNumber),
        // we need to ensure the Connection mock correctly handles the SQL generated by QueryBuilder.

        $this->migrationsPath = sys_get_temp_dir() . '/yourorm_test_migrations_' . uniqid();
        if (!is_dir($this->migrationsPath)) {
            mkdir($this->migrationsPath, 0777, true);
        }

        // Configure Connection mock to return PDOStatement mocks for QueryBuilder's needs
        // This is a simplified way; a more robust mock would inspect the SQL from QueryBuilder.
        $stmtMock = $this->createMock(PDOStatement::class);
        // Default behavior for execute, can be overridden per test
        $this->connectionMock->method('execute')->willReturn($stmtMock);
        // Default behavior for QueryBuilder's fetch/fetchAll results via the stmtMock
        $stmtMock->method('fetch')->willReturn(null); // e.g. for MAX(batch) when no batches
        $stmtMock->method('fetchAll')->willReturn([]); // e.g. for getExecutedMigrations when table is empty

        $this->migrator = new Migrator($this->connectionMock, $this->migrationsPath);

        CreateUsersTable_20230101000000::$upCalled = false;
        CreateUsersTable_20230101000000::$downCalled = false;
    }

    protected function tearDown(): void
    {
        // Clean up dummy migration files and directory
        if (is_dir($this->migrationsPath)) {
            $files = glob($this->migrationsPath . '/*.php');
            foreach ($files as $file) {
                unlink($file);
            }
            rmdir($this->migrationsPath);
        }
    }

    private function createDummyMigrationFile(string $name, string $className, string $namespace = 'YourOrm\\Migration\\Database'): void
    {
        $content = <<<PHP
<?php
namespace {$namespace};
use YourOrm\Migration\AbstractMigration;
use YourOrm\Migration\SchemaBuilder;
class {$className} extends AbstractMigration {
    public static \$upCalled = false; public static \$downCalled = false;
    public function up(SchemaBuilder \$s): void { self::\$upCalled = true; }
    public function down(SchemaBuilder \$s): void { self::\$downCalled = true; }
}
PHP;
        file_put_contents($this->migrationsPath . '/' . $name . '.php', $content);
    }

    public function testEnsureMigrationsTableExistsWhenTableDoesNotExist()
    {
        // Setup: Simulate table not existing by having the initial SELECT 1 FROM migrations throw PDOException
        $this->connectionMock->expects($this->atLeastOnce())
            ->method('execute')
            ->willReturnCallback(function (string $sql) {
                if (str_contains($sql, "SELECT 1 FROM `migrations` LIMIT 1")) {
                    throw new PDOException("Table not found", "42S02");
                }
                // For the CREATE TABLE statement by SchemaBuilder
                $stmt = $this->createMock(PDOStatement::class);
                $this->assertStringContainsString("CREATE TABLE `migrations`", $sql);
                return $stmt;
            });

        // Re-initialize migrator to trigger ensureMigrationsTableExists with the mocked behavior
        new Migrator($this->connectionMock, $this->migrationsPath);
    }


    public function testGetAllMigrationFiles()
    {
        $this->createDummyMigrationFile('20230101000000_CreateUsersTable', 'CreateUsersTable_20230101000000');
        $this->createDummyMigrationFile('20230102000000_AddStatusToUsersTable', 'AddStatusToUsersTable_20230102000000');
        file_put_contents($this->migrationsPath . '/not_a_migration.txt', 'hello'); // Non-PHP file
        file_put_contents($this->migrationsPath . '/InvalidNameFormat.php', '<?php class Invalid {}');


        $files = $this->migrator->getAllMigrationFiles();
        $this->assertCount(2, $files);
        $this->assertEquals('20230101000000_CreateUsersTable', $files[0]);
        $this->assertEquals('20230102000000_AddStatusToUsersTable', $files[1]);
    }

    public function testGetExecutedMigrations()
    {
        $stmtMock = $this->createMock(PDOStatement::class);
        $expectedData = [
            ['migration' => '20230101000000_CreateUsersTable', 'batch' => 1, 'executed_at' => '...'],
        ];
        $stmtMock->method('fetchAll')->willReturn($expectedData);

        // This is tricky because Migrator creates its own QB.
        // We need Connection::execute, when called with SQL from QB for getExecutedMigrations, to return this stmtMock.
        $this->connectionMock->method('execute')
            ->with($this->stringContains("SELECT migration, batch, executed_at FROM `migrations` ORDER BY migration ASC"))
            ->willReturn($stmtMock);

        $executed = $this->migrator->getExecutedMigrations();
        $this->assertArrayHasKey('20230101000000_CreateUsersTable', $executed);
        $this->assertEquals(1, $executed['20230101000000_CreateUsersTable']['batch']);
    }

    public function testGetPendingMigrations()
    {
        $this->createDummyMigrationFile('20230101000000_CreateUsersTable', 'CreateUsersTable_20230101000000');
        $this->createDummyMigrationFile('20230102000000_AddStatusToUsersTable', 'AddStatusToUsersTable_20230102000000');

        $stmtMock = $this->createMock(PDOStatement::class);
        $executedDbData = [
            ['migration' => '20230101000000_CreateUsersTable', 'batch' => 1, 'executed_at' => '...'],
        ];
        $stmtMock->method('fetchAll')->willReturn($executedDbData);
        $this->connectionMock->method('execute')
             ->with($this->stringContains("SELECT migration, batch, executed_at FROM `migrations`"))
             ->willReturn($stmtMock);

        $pending = $this->migrator->getPendingMigrations();
        $this->assertCount(1, $pending);
        $this->assertEquals('20230102000000_AddStatusToUsersTable', $pending[0]);
    }

    public function testRunUp()
    {
        $migrationName = '20230101000000_CreateUsersTable';
        $className = 'CreateUsersTable_20230101000000';
        $this->createDummyMigrationFile($migrationName, $className);

        // Mock for logging migration (INSERT into migrations table)
        $logStmtMock = $this->createMock(PDOStatement::class);
        // Mock for getting next batch number (SELECT MAX(batch))
        $batchStmtMock = $this->createMock(PDOStatement::class);
        $batchStmtMock->method('fetch')->willReturn(['max_batch' => null]); // No batches yet, next is 1

        $this->connectionMock->expects($this->exactly(2)) // One for MAX(batch), one for INSERT log
            ->method('execute')
            ->willReturnCallback(function(string $sql) use ($batchStmtMock, $logStmtMock){
                if (str_contains($sql, "MAX(batch)")) {
                    return $batchStmtMock;
                } elseif (str_contains($sql, "INSERT INTO `migrations`")) {
                    $this->assertStringContainsString($migrationName, $sql); // Check name in log
                    $this->assertStringContainsString("1", $sql); // Check batch 1 in log
                    return $logStmtMock;
                }
                // SchemaBuilder calls execute too for CREATE TABLE etc.
                // For this test, we only care about Migrator's direct execute calls.
                // The dummy migration's up() is empty, so no SchemaBuilder calls.
                // If up() made calls, we'd need to mock them too or make the callback smarter.
                return $this->createMock(PDOStatement::class);
            });

        $this->migrator->runUp($migrationName);
        $this->assertTrue(CreateUsersTable_20230101000000::$upCalled);
    }

    // TODO: Test runDown similarly
    // TODO: Test batching logic for rollback if time permits
}
